#!/usr/bin/env python
from __future__ import annotations

import hashlib
import json
import os
import pathlib
import shlex
import shutil
import subprocess
import sys
import tempfile

BASE_PATH = pathlib.Path(__file__).parent.resolve()

try:
    from hatchling.builders.hooks.plugin.interface import BuildHookInterface
except ImportError:
    BuildHookInterface = object


class CustomBuildHook(BuildHookInterface):
    def initialize(self, version, build_data):
        run()

        build_data["force_include"].update(
            {
                "dist/yt.solver.core.min.js": "yt_dlp_ejs/yt/solver/core.min.js",
                "dist/yt.solver.lib.min.js": "yt_dlp_ejs/yt/solver/lib.min.js",
            }
        )

    def clean(self, versions):
        shutil.rmtree("node_modules", ignore_errors=True)


class Package:
    def __init__(
        self,
        /,
        name: str,
        description: str,
        version: str,
        author: str,
        repository: str,
        license: str,
        license_text: str,
    ):
        self.name = name
        self.description = description
        self.version = version
        self.author = author
        self.repository = repository
        self.license = license
        self.license_text = license_text

    @staticmethod
    def _parse_author(author):
        if isinstance(author, str):
            return author

        result = [author["name"]]
        if email := author.get("email"):
            result.append(f"<{email}>")
        if url := author.get("url"):
            result.append(f"({url})")
        return " ".join(result)

    @classmethod
    def parse(cls, path: pathlib.Path, /):
        with path.open("rb") as file:
            data = json.load(file)

        licenses = list(path.parent.glob("LICENSE*"))
        if len(licenses) != 1:
            msg = "could not find appropriate license"
            raise ValueError(msg)

        return cls(
            name=data["name"],
            version=data["version"],
            author=cls._parse_author(data["author"]),
            description=data["description"],
            repository=data["repository"]["url"],
            license=data["license"],
            license_text=licenses[0].read_text(encoding="utf-8"),
        )

    def _license_comment(self, /):
        for name in (
            "name",
            "description",
            "version",
            "author",
            "repository",
            "license",
            "license_text",
        ):
            if name == "license_text":
                yield "\n"
            else:
                yield name.capitalize()
                yield ": "
            yield getattr(self, name)
            yield "\n"

    def license_comment(self, /):
        return "".join(self._license_comment())


def license_comment(data: str):
    return "/*!\n * " + "\n * ".join(data.splitlines()) + "\n */"


def null():
    return "NUL" if os.name == "nt" else "/dev/null"


def create_builds(esbuild: list[str]):
    with (BASE_PATH / "package.json").open("rb") as file:
        pkg = json.load(file)
    LICENSE_PREAMBLE = f"""\
    SPDX-License-Identifier: Unlicense
    This file was automatically generated by {pkg["homepage"]}
    """

    fd, name = tempfile.mkstemp(prefix="ejs-build-metadata-", suffix=".json")
    try:
        process = subprocess.run(
            [
                *esbuild,
                "--bundle",
                "--abs-paths=metafile",
                f"--metafile={name}",
                f"--outfile={null()}",
                str(BASE_PATH / "src/yt/solver/lib.ts"),
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            check=False,
        )
        if process.returncode:
            msg = "Failed to gather build metadata:\n" + process.stderr
            raise RuntimeError(msg)

        with open(fd, "rb", closefd=True) as file:
            metafile = json.load(file)
    finally:
        os.unlink(name)

    _externals = {}
    for input_file, meta in metafile["inputs"].items():
        try:
            pathlib.Path(input_file).relative_to(BASE_PATH)
        except ValueError:
            continue
        for import_meta in meta["imports"]:
            if "." in (import_meta.get("original") or ""):
                continue
            path = pathlib.Path(import_meta["path"])
            _externals[path] = None

    externals: list[Package] = []
    for path in _externals:
        current = path.parent
        while current != BASE_PATH:
            package_path = current / "package.json"
            if package_path.is_file():
                break
            current = current.parent
        else:
            msg = f"Failed to find package dir for {path}"
            raise ValueError(msg)

        externals.append(Package.parse(current / "package.json"))

    BANNER_WITHOUT_DEPENDENCIES = "--banner:js=" + license_comment(LICENSE_PREAMBLE)
    BANNER_WITH_DEPENDENCIES = "--banner:js=" + license_comment(
        LICENSE_PREAMBLE
        + "\n\nBundled dependencies:\n\n"
        + "------\n\n".join(map(Package.license_comment, externals))
    )
    MAPPING_DENO = {pkg.name: f"npm:{pkg.name}@{pkg.version}" for pkg in externals}
    MAPPING_BUN = {pkg.name: f"{pkg.name}@{pkg.version}" for pkg in externals}
    EXTERNALS = [f"--external:{pkg.name}" for pkg in externals]

    def aliases_and_externals(mapping: dict[str, str]):
        for name, target in mapping.items():
            yield f"--external:{target}"
            yield f"--alias:{name}={target}"

    return [
        (
            "src/yt/solver/main.ts",
            "dist/yt.solver.core.js",
            [
                "--format=iife",
                "--global-name=jsc",
                BANNER_WITHOUT_DEPENDENCIES,
                *EXTERNALS,
            ],
        ),
        (
            "src/yt/solver/main.ts",
            "dist/yt.solver.core.min.js",
            [
                "--minify",
                "--format=iife",
                "--global-name=jsc",
                BANNER_WITHOUT_DEPENDENCIES,
                *EXTERNALS,
            ],
        ),
        (
            "src/yt/solver/lib.ts",
            "dist/yt.solver.lib.js",
            [
                "--format=iife",
                "--global-name=lib",
                BANNER_WITH_DEPENDENCIES,
            ],
        ),
        (
            "src/yt/solver/lib.ts",
            "dist/yt.solver.lib.min.js",
            [
                "--minify",
                "--format=iife",
                "--global-name=lib",
                BANNER_WITH_DEPENDENCIES,
            ],
        ),
        (
            "src/yt/solver/lib.ts",
            "dist/yt.solver.bun.lib.js",
            [
                "--format=esm",
                "--minify-syntax",
                BANNER_WITHOUT_DEPENDENCIES,
                *aliases_and_externals(MAPPING_BUN),
            ],
        ),
        (
            "src/yt/solver/lib.ts",
            "dist/yt.solver.deno.lib.js",
            [
                "--format=esm",
                "--minify-syntax",
                BANNER_WITHOUT_DEPENDENCIES,
                *aliases_and_externals(MAPPING_DENO),
            ],
        ),
    ]


def build_install_cmd():
    env = os.environ.copy()

    if pnpm := shutil.which("pnpm"):
        cmd = [pnpm, "install", "--frozen-lockfile"]

    elif deno := shutil.which("deno"):
        env["DENO_NO_UPDATE_CHECK"] = "1"
        cmd = [deno, "install", "--frozen"]

    elif bun := shutil.which("bun"):
        cmd = [bun, "install", "--frozen-lockfile"]

    elif npm := shutil.which("npm"):
        cmd = [npm, "ci"]

    else:
        raise RuntimeError(
            "One of 'pnpm', 'deno', 'bun', or 'npm' could not be found. "
            "Please install one of them to automatically install dependencies."
        )

    return cmd, env


def build_bundle_cmd():
    env = os.environ.copy()

    if esbuild := shutil.which("esbuild"):
        cmd = [esbuild]

    elif pnpm := shutil.which("pnpm"):
        cmd = [pnpm, "run", "esbuild"]

    elif deno := shutil.which("deno"):
        env["DENO_NO_UPDATE_CHECK"] = "1"
        cmd = [deno, "task", "esbuild"]

    elif bun := shutil.which("bun"):
        cmd = [bun, "--bun", "run", "esbuild"]

    elif npm := shutil.which("npm"):
        cmd = [npm, "run", "esbuild"]

    else:
        raise RuntimeError(
            "One of 'esbuild', 'pnpm', 'deno', 'bun', or 'npm' could not be found. "
            "Please install one of them to bundle the TypeScript files."
        )

    return cmd, env


def run():
    if not os.environ.get("EJS_BUILD_SKIP_INSTALL"):
        cmd, env = build_install_cmd()
        print(f"Install command: {shlex.join(cmd)}")
        subprocess.run(cmd, env=env, check=True)
    cmd, env = build_bundle_cmd()
    print(f"Bundle cmd: {shlex.join(cmd)}", file=sys.stderr)

    builds = create_builds(cmd)
    print("SHA3-512 checksums:", file=sys.stderr)
    for src, dst, args in builds:
        process = subprocess.run(
            [
                *cmd,
                "--bundle",
                *args,
                str(BASE_PATH / src),
                f"--outfile={BASE_PATH / dst}",
            ],
            env=env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.PIPE,
            text=True,
            check=False,
        )
        if process.returncode:
            raise RuntimeError(process.stderr)

        path = BASE_PATH / dst
        digest = hashlib.sha3_512(path.read_bytes()).hexdigest()
        print(f"{digest} {path.name}")


if __name__ == "__main__":
    import sys

    try:
        run()
    except RuntimeError as error:
        print("ERROR:", error.args[0], file=sys.stderr)
        sys.exit(128)
